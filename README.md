# ODB1_Bank

_Created for the course "Organization of databases" V. N. Karazin Kharkiv National University_

Design and implementation of the Bank's information system (IS) model.

---

В данній проботі розглядається проєктування та реалізація моделі інформаційної системи (ІС) Банку з використанням CASE-засобів.

# Завдання

Вариант №27
Банк
В базе данных должны храниться сведения о счетах клиентов банка, о размерах счета и о самих клиентах. Одним счетом могут пользоваться один и более клиентов. Счета могут открываться в разных валютах гривна, рубли, доллары и евро. Операции, которые могут выполнять клиенты со своим счетом: открытие, закрытие, пополнение счета, а также снятие денег со счета. Банк начисляет проценты на счет в определённые моменты Времени. В базе данных должна храниться история финансовых операций с каждым счетом. Также должны быть данные о курсах валют для перерасчета денег на счетах на каждый день работы банка. Курс валют неизменен в течение всего дня и должен быть известен на каждый день работы банка. Процент по всем счетам равен 10%. Начисление процента на заданный счет выполняется путем формирования в таблице истории счетов для заданного счета записи о его пополнении суммой, равной 10% от остатка наличности на этом счете.

Запросы:
- Проверить согласованность записей об операциях со счетами (истории счетов) с размерами остатка на счетах и выдать номера счетов, в которых имеются расхождения;
- Найти счет, с которым совершили больше всего операций;
- Найти счета, с которых ни разу не снимали деньги
- Для данного клиента выдать отчет обо всех операция с его счетами;
- Для данного счета пересчитать его содержимое из одной заданной валюты в другую заданную валюту.

Транзакции:
- Выполнение операций со счетом клиента
- Начисление процентов на счет банком и задание курсов валют на новый день работы банка.

# IDEF0, IDEF3, DFD представлення

Створимо представлення ІС Банку за допомогою CASE-засобів:

Робота A-0 базовий блок:
![A-0](https://github.com/user-attachments/assets/7ed022d8-e2c4-4f5d-8d95-46c79c784bd1)

Робота A0 (IDEF0) декомпозиція блока А-0:
![A0](https://github.com/user-attachments/assets/5449ec27-67d1-4f78-b4dd-01a0326313ad)

Робота A1 (DFD), відповідатиме за управління рахунками
клієнтів:
![A1](https://github.com/user-attachments/assets/d18b3bb4-f05f-4783-b3dd-8aa79eb340bd)

Робота A2 (DFD), відповідатиме за управління операціями,
історією, аудит:
![A2](https://github.com/user-attachments/assets/9a6e4409-de86-44b7-99bf-f61a446d1e39)

Робота A3.1 (IDEF3), відповідатиме за управління курсами
валют, перерахунок відсотків в інших валютах.:
![A3 1](https://github.com/user-attachments/assets/f5b50105-92e9-472d-8dea-e15ff6234d4f)

Робота A4 (DFD), відповідатиме за нарахування відсотків:
![A4](https://github.com/user-attachments/assets/5fb4bd12-445f-4e96-b1b9-d2a2fcf32eed)

Загальна діаграма дерева вузлів:
![image](https://github.com/user-attachments/assets/edcdbac8-4049-472f-8347-3d2a238b9418)

# ER-модель (IDEF1X)

#### **Основні сутності та їх атрибути:**

1. **Client (Клієнт)**:

   - `client_id` (PK): Унікальний ідентифікатор клієнта
   - `name`: Ім'я клієнта
   - `address`: Адреса клієнта
   - `phone`: Номер телефону клієнта
   - `email`: Електронна пошта клієнта

2. **Account (Рахунок)**:

   - `account_id` (PK): Унікальний ідентифікатор рахунку
   - `currency`: Тип валюти (UAH, USD, EUR, RUB)
   - `balance`: Поточний баланс рахунку
   - `creation_date`: Дата відкриття рахунку
   - `client_id` (FK): Ідентифікатор клієнта (зв'язок з таблицею Client)

3. **Transactions (Операція)**:

   - `transaction_id` (PK): Унікальний ідентифікатор операції
   - `client_id` (FK): Ідентифікатор клієнта (зв'язок з таблицею Client)
   - `account_from_id` (FK): Ідентифікатор рахунку (зв'язок з таблицею Account)
   - `account_to_id` (FK): Ідентифікатор рахунку, з яким пов'язана операція (для конвертації валют)
   - `currency_rate_id` (FK): Унікальний ідентифікатор курсу
   - `transaction_type`: Тип операції (Deposit, Withdrawal, Interest, Exchange)
   - `amount`: Сума операції
   - `transaction_date`: Дата виконання операції
   - `currency`: Валюта операції

4. **Interest (Нарахування відсотків)**:

   - `interest_id` (PK): Унікальний ідентифікатор нарахування
   - `account_id` (FK): Ідентифікатор рахунку (зв'язок з таблицею Account)
   - `interest_rate`: Відсоткова ставка (фіксована 10%)
   - `calculation_date`: Дата нарахування
   - `amount`: Сума нарахованих відсотків

5. **CurrencyRate (Курс Валют)**:
   - `currency_rate_id` (PK): Унікальний ідентифікатор курсу
   - `currency_from`: Валюта, з якої конвертують
   - `currency_to`: Валюта, в яку конвертують
   - `rate`: Курс обміну (наприклад, 1 USD = 27.5 UAH)
   - `rate_date`: Дата встановлення курсу

#### **Зв'язки між сутностями:**

- Один **Client** може мати декілька **Account**.
- Один **Account** може мати декілька **Transactions**.
- Один **Account** може мати декілька нарахувань **Interest**.
- **CurrencyRate** зберігає курс обміну між валютами на конкретну дату.

За допомогою CASE-засобів створимо логічний рівень:
![image](https://github.com/user-attachments/assets/47e15009-0460-4934-acba-2ac497ebdfae)

За логічним рівнем згенеруємо фізичний рівень:
![image](https://github.com/user-attachments/assets/c4f19277-acab-48f8-b1bb-a353cd6217f6)

Отримана ER-модель відповідає формам 1NF, 2NF, 3NF, BCNF.
В цій моделі відсутні рекурсивні зв’язки, оскільки жодна сутність не повинна напряму взаємодіяти сама з собою (з такою ж сутністю).

# Приклад запиту мовою реляційної алгебри

Виконаємо мовою реляційної алгебри запит 4: 

Для конкретного клієнта знайти усі рахунки, для кожного з них знайти усі транзакції що були виконані з ним.

Запит:

1.	Отримати всі рахунки конкретного клієнта (з ідентифікатором `C1`):

`Account WHERE client_id = ′C1′`

2.	Отримати всі транзакції, виконані для рахунків цього клієнта:

`((Account WHERE client_id = ′C1′) JOIN Transactions )[transaction_id, account_from_id, account_to_id, transaction_type, amount, transaction_date]`


Докладніше:

1.	Вибрати всі рахунки клієнта з ідентифікатором `C1`:

`T1 := Account WHERE client_id = ′C1′`

2.	З'єднати таблицю рахунків із таблицею транзакцій за `account_id`:

`T2 := T1 JOIN Transactions `

3.	Проекція результату для виводу всіх атрибутів транзакцій:

`T3 := T2[transaction_id, account_from_id, account_to_id, transaction_type, amount, transaction_date] `

У результаті отримаємо всі транзакції, виконані для рахунків клієнта з `client_id = 'C1'`.

# Бізнес-правила:

1. **Клієнти та рахунки:**
   - Кожен клієнт має унікальний ідентифікатор (client_id), адресу, телефон та email. Телефон має бути унікальним і позитивним числом. Email має бути унікальним і правильним за форматом.
   - Клієнт може мати кілька рахунків (через поле client_id в таблиці `Account`), де кожен рахунок має валюту та баланс.

2. **Обмін валют:**
   - Курс валют для конвертації з однієї валюти в іншу зберігається в таблиці `CurrencyRate`, де кожен запис має унікальний ID, валюту, курс та дату. Для кожної пари валют (currency_from, currency_to) може бути кілька курсів за різні дати.

3. **Транзакції:**
   - Кожна транзакція має унікальний ідентифікатор (transaction_id) та вказує, який рахунок використовувався для відправлення та отримання коштів.
   - Транзакції можуть бути різних типів: `Interest`, `Exchange`, `Transfer`, де `Interest` нараховує відсотки на баланс, `Exchange` виконує обмін валют, а `Transfer` — переказ коштів між рахунками.
   - Для обміну валют за допомогою транзакцій використовується найсвіжіший курс з таблиці `CurrencyRate`.

4. **Нарахування відсотків:**
   - Кожен рахунок має можливість нарахування відсотків. Відсотки нараховуються на баланс рахунку клієнта (по суті це окрема транзакція типу `Interest`), де сума нарахованих відсотків обчислюється як 10% від поточного балансу рахунку.
   - Відсотки зберігаються в таблиці `Interest`, де зазначається ставка відсотків (1.10 — що означає нарахування 10%) та відповідна сума.

5. **Баланс рахунку:**
   - Після кожної транзакції необхідно оновлювати баланс рахунку. Це стосується як поповнень, так і витрат.
   - Баланс повинен мати точність що дорівнює мінімальній грошовій одиниці (в цьому прикладі це 1 копійка = 0.01).

6. **Безпека даних:**
   - Для кожного рахунку та транзакції є зовнішні ключі, що забезпечують цілісність даних між таблицями.
   - При видаленні клієнтів, рахунків або транзакцій також видаляються всі пов'язані записи в інших таблицях (наприклад, транзакції для певного клієнта).

# Опис таблиць:

### Опис стовпців таблиць:
- **PKEY**: первинний ключ (Primary Key), позначено "X".
- **FKEY**: зовнішній ключ (Foreign Key), де зазначено ім'я зовнішнього ключа.
- **ALLOW NULLS**: дозволено чи не дозволено значення NULL. "Yes" — дозволено, "No" — не дозволено.
- **UNIQUE**: чи є атрибут унікальним для кожного запису. Позначено "X", якщо це унікальний стовпець.

#### 1. **Client**
   Таблиця містить інформацію про клієнтів:
   - `client_id`: Унікальний ідентифікатор клієнта (тип INT).
   - `name`: Ім'я клієнта (тип VARCHAR).
   - `address`: Адреса клієнта (тип VARCHAR).
   - `phone`: Телефон клієнта (тип DECIMAL). Має бути унікальним та позитивним числом.
   - `email`: Email клієнта (тип VARCHAR). Має бути унікальним і відповідати формату email.

| Ім'я атрибута | Фізичне ім'я   | Тип даних T-SQL | PKEY | FKEY | ALLOW NULLS | UNIQUE  |
|---------------|----------------|-----------------|------|------|-------------|---------|
| client_id     | client_id      | INT             | X    |      | No          | X       |
| name          | name           | VARCHAR(100)    |      |      | No          |         |
| address       | address        | VARCHAR(255)    |      |      | Yes         |         |
| phone         | phone          | DECIMAL(18,0)   |      |      | Yes         | X       |
| email         | email          | VARCHAR(100)    |      |      | Yes         | X       |

#### 2. **Account**
   Таблиця зберігає інформацію про рахунки клієнтів:
   - `account_id`: Унікальний ідентифікатор рахунку (тип INT).
   - `client_id`: Ідентифікатор клієнта, до якого належить рахунок (тип INT). Це зовнішній ключ до таблиці `Client`.
   - `currency`: Валюта рахунку (тип VARCHAR).
   - `balance`: Баланс рахунку (тип DECIMAL). Має бути позитивним значенням.
   - `creation_date`: Дата створення рахунку (тип DATETIME2).

| Ім'я атрибута  | Фізичне ім'я   | Тип даних T-SQL | PKEY | FKEY        | ALLOW NULLS | UNIQUE  |
|----------------|----------------|-----------------|------|-------------|-------------|---------|
| account_id     | account_id     | INT             | X    |             | No          | X       |
| client_id      | client_id      | INT             |      | client_id   | No          |         |
| currency       | currency       | VARCHAR(10)     |      |             | No          |         |
| balance        | balance        | DECIMAL(18,2)   |      |             | No          |         |
| creation_date  | creation_date  | DATETIME2       |      |             | Yes         |         |

#### 3. **CurrencyRate**
   Таблиця для зберігання курсів валют:
   - `currency_rate_id`: Унікальний ідентифікатор курсу (тип INT).
   - `currency_from`: Валюта, з якої здійснюється обмін (тип VARCHAR).
   - `currency_to`: Валюта, в яку здійснюється обмін (тип VARCHAR).
   - `rate`: Курс обміну валют (тип DECIMAL).
   - `rate_date`: Дата курсу (тип DATE). Це допомагає зберігати кілька курсів за різні дати.
   - Зовнішній ключ забезпечує унікальність пари валют і дати.

| Ім'я атрибута  | Фізичне ім'я   | Тип даних T-SQL | PKEY | FKEY | ALLOW NULLS | UNIQUE  |
|----------------|----------------|-----------------|------|------|-------------|---------|
| currency_rate_id | currency_rate_id | INT             | X    |      | No          | X       |
| currency_from   | currency_from   | VARCHAR(10)     |      |      | No          |         |
| currency_to     | currency_to     | VARCHAR(10)     |      |      | No          |         |
| rate            | rate            | DECIMAL(18,2)   |      |      | No          |         |
| rate_date       | rate_date       | DATE            |      |      | Yes         |         |

**Унікальний комбінований індекс для `currency_from`, `currency_to`, та `rate_date` (уникає дублювання записів для кожної пари валют на конкретну дату).**

#### 4. **Transactions**
   Таблиця для зберігання транзакцій між рахунками:
   - `transaction_id`: Унікальний ідентифікатор транзакції (тип INT).
   - `client_id`: Ідентифікатор клієнта, який здійснив транзакцію (тип INT).
   - `account_from_id`: Ідентифікатор рахунку, з якого здійснено транзакцію (тип INT).
   - `account_to_id`: Ідентифікатор рахунку, на який здійснено транзакцію (тип INT).
   - `currency_rate_id`: Ідентифікатор курсу валют, що застосовується для обміну (тип INT).
   - `transaction_type`: Тип транзакції (тип VARCHAR). Може бути "Interest", "Exchange", "Transfer".
   - `amount`: Сума транзакції (тип DECIMAL).
   - `currency`: Валюта транзакції (тип VARCHAR).
   - `transaction_date`: Дата транзакції (тип DATETIME2).

| Ім'я атрибута   | Фізичне ім'я    | Тип даних T-SQL | PKEY | FKEY                                | ALLOW NULLS | UNIQUE  |
|-----------------|-----------------|-----------------|------|-------------------------------------|-------------|---------|
| transaction_id  | transaction_id  | INT             | X    |                                     | No          | X       |
| client_id       | client_id       | INT             |      | client_id                          | No          |         |
| account_from_id | account_from_id | INT             |      | account_id (в таблиці `Account`)   | Yes         |         |
| account_to_id   | account_to_id   | INT             |      | account_id (в таблиці `Account`)   | Yes         |         |
| currency_rate_id| currency_rate_id| INT             |      | currency_rate_id (в таблиці `CurrencyRate`) | Yes |         |
| transaction_type| transaction_type| VARCHAR(50)     |      |                                     | No          |         |
| amount          | amount          | DECIMAL(18,2)   |      |                                     | No          |         |
| currency        | currency        | VARCHAR(10)     |      |                                     | Yes         |         |
| transaction_date| transaction_date| DATETIME2       |      |                                     | Yes         |         |

#### 5. **Interest**
   Таблиця для зберігання нарахованих відсотків на рахунки:
   - `interest_id`: Унікальний ідентифікатор для нарахованого відсотка (тип INT).
   - `account_id`: Ідентифікатор рахунку, на який нараховуються відсотки (тип INT).
   - `transaction_id`: Ідентифікатор транзакції, яка нараховує відсотки (тип INT).
   - `interest_rate`: Ставка відсотків (тип DECIMAL).
   - `calculation_date`: Дата нарахування відсотків (тип DATE).
   - `amount`: Сума нарахованих відсотків (тип DECIMAL).

| Ім'я атрибута    | Фізичне ім'я    | Тип даних T-SQL | PKEY | FKEY                            | ALLOW NULLS | UNIQUE  |
|------------------|-----------------|-----------------|------|---------------------------------|-------------|---------|
| interest_id      | interest_id     | INT             | X    |                                 | No          | X       |
| account_id       | account_id      | INT             |      | account_id (в таблиці `Account`) | No          |         |
| transaction_id   | transaction_id  | INT             |      | transaction_id (в таблиці `Transactions`) | No   |         |
| interest_rate    | interest_rate   | DECIMAL(5,2)    |      |                                 | No          |         |
| calculation_date | calculation_date| DATE            |      |                                 | Yes         |         |
| amount           | amount          | DECIMAL(18,2)   |      |                                 | No          |         |

# Приклади скриптів створення/додання/зміни/оновлення/видалення таблиць та данних T-SQL знаходяться в папці `TSQL`

# Робота з Docker (в папці `TSQL`)
## Робочий процес Docker

### Docker-образ
Проєкт використовує офіційний **MS SQL Server 2022** Docker-образ для запуску екземпляра Microsoft SQL Server у контейнері. Використовуваний образ:

```docker
FROM mcr.microsoft.com/mssql/server:2022-latest
```

### Файли в проєкті
- **Dockerfile**: Цей файл використовується для побудови контейнерного образу. Він налаштовує середовище, визначаючи робочу директорію, копіюючи SQL-файли в контейнер, приймаючи EULA та встановлюючи пароль SA для MS SQL Server.
  
- **docker-compose.yaml**: Цей файл визначає сервіси, включаючи контейнер MS SQL Server, який будується з Dockerfile. Він вказує налаштування портів, налаштування томів для збереження даних і змінні середовища контейнера, такі як пароль SA.

### Зберігання даних
Файли бази даних та дані контейнера зберігаються в іменованому томі `bunk-mssql-storage`, який монтується до `/var/opt/mssql` в контейнері. Це гарантує, що дані зберігаються навіть у випадку зупинки чи видалення контейнера.

### Запуск контейнера
Щоб запустити контейнер MS SQL Server з усіма необхідними сервісами, використовуйте наступну команду:

```bash
docker compose up -d
```

Це запустить контейнер у відключеному режимі (флаг `-d`).

### Зупинка та видалення контейнера
Щоб зупинити та видалити контейнер, виконайте:

```bash
docker compose down
```

Це зупинить контейнер і видалить його, включаючи мережу та будь-які томи, пов'язані з сервісами, визначеними у `docker-compose.yaml`.

### Доступ до SQL Server контейнера
Ви можете підключитися до контейнера MS SQL Server через командний рядок, використовуючи наступну команду:

```bash
docker exec -it bunk-mssql /opt/mssql-tools18/bin/sqlcmd -S localhost -U sa -P 'StrongPass123!' -C
```

Це відкриє інтерактивну сесію з SQL Server.

### Виконання SQL-запитів
Щоб виконати SQL-скрипти, ви можете використовувати наступну команду, де `SETUP.SQL` — це SQL-скрипт, який ви хочете виконати:

```bash
docker exec -i bunk-mssql /opt/mssql-tools18/bin/sqlcmd -S localhost -U sa -P 'StrongPass123!' -C -i SETUP.SQL
```

Це виконає скрипт всередині контейнера.

### Перевірка таблиць
Щоб перевірити дані в таблиці `Client` (наприклад), використовуйте:

```bash
docker exec -it bunk-mssql /opt/mssql-tools18/bin/sqlcmd -S localhost -U sa -P 'StrongPass123!' -C
1> SELECT TOP 10 * FROM Client;
2> GO
```

Це поверне перші 10 рядків з таблиці `Client`.

### Виконання запитів і збереження виводу
Щоб виконати запит і зберегти вивід у файл, виконайте:

```bash
docker exec -i bunk-mssql /opt/mssql-tools18/bin/sqlcmd -S localhost -U sa -P 'StrongPass123!' -C -i QUERY.SQL -o output.txt
```

Ця команда виконає запити з `QUERY.SQL` і збереже результат у файл `output.txt`.

### Примітки
- **Порти**: Контейнер відкриває порт `1433`, що є портом за замовчуванням для SQL Server.
- **Об'єми**: Дані зберігаються постійно в томі `bunk-mssql-storage`, що гарантує збереження бази даних, навіть коли контейнер зупиняється чи видаляється.

---

## Швидке одноразове тестування БД за допомогою `docker-compose2.yaml`

Для одноразового, швидкого тестування бази даних можна використати файл `docker-compose2.yaml`, який:

- **не потребує** створення образу контейнера через `Dockerfile`;
- використовує **стоковий образ**;
- **підключає локальну робочу папку** як том контейнера, що дозволяє змінювати файли запитів у реальному часі та одразу тестувати їх.

### Запуск контейнера

```bash
docker compose -f docker-compose2.yaml up
````

Конфігурація `compose` автоматично виконує всі запити у правильній послідовності та зберігає результати важливих запитів у локальну папку.

### Первинне налаштування БД

На етапі первинного налаштування база даних автоматично створюється всередині контейнера за допомогою скрипта `SETUP.SQL` (див. Додаток А).

У цьому скрипті:

* створюються основні таблиці;
* створюються технічні таблиці (наприклад, журнали, логування тощо), які використовуються у допоміжних аналітичних або логічних запитах.

Для наповнення бази даних використовується скрипт `INSERT.SQL` (див. Додаток А), який:

* генерує та вставляє **по 10 000 тестових записів** у кожну з основних таблиць;
* дозволяє одразу перевірити ефективність запитів на великих обсягах даних.

### Завершення тестування

Після завершення тестування контейнер можна зупинити:

```bash
docker compose -f docker-compose2.yaml down
```

Або з повним очищенням, включно з видаленням БД:

```bash
docker compose -f docker-compose2.yaml down --volumes
```

Це **еквівалентно ручному очищенню БД**, і дозволяє при наступному запуску відтворити процес з нуля, що зручно для повторних тестів із гарантовано однаковим початковим станом.

З цією конфігурацією ви можете запускати контейнер MS SQL Server на Docker, керувати операціями з базою даних і виконувати SQL-запити без впливу на хост-машину.
